Package compiler;

Helpers
    unicode_input_character = [0..0xffff];
    ht  = 0x0009;
    lf  = 0x000a;
    ff  = 0x000c;
    cr  = 0x000d;
    sp  = ' ';

    line_terminator = lf | cr | cr lf;
    input_character = [unicode_input_character - [cr + lf]];

    input_string = [input_character - ['"' + '\']];

    not_dollar = [input_character - '$'];

    white_space = (sp | ht | ff | line_terminator);

    traditional_comment = '$$' not_dollar* ('$' (not_dollar)+)* '$$';

    end_of_line_comment = '$' (not_dollar input_character*)* line_terminator;

    digit = ['0'..'9'];
    lowercase = ['a'..'z'];
    uppercase = ['A'..'Z'];
    letter  = lowercase | uppercase;

    hex_digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F';
    escape_sequence = '\n' | '\t' | '\r' | '\0' | '\\' | '\' ''' | '\' '"' | '\x' hex_digit hex_digit;

Tokens
    comment = end_of_line_comment | traditional_comment;

    plus = '+';
    minus = '-';
    mult = '*';
    division = '/';
    div = 'div';
    mod = 'mod';

    assign = '<-';
    equal = '=';
    n_equal =  '#';
    less = '<';
    less_equal = '<=';
    greater = '>';
    greater_equal = '>=';

    l_par = '(';
    r_par = ')';
    l_brc = '{';
    r_brc = '}';
    l_bkt = '[';
    r_bkt = ']';
    semi = ';';
    comma = ',';
    colon = ':';

    number = digit+;
  //  number = '0' | [digit-'0'] digit*;

    const_char   = ''' (letter | digit | escape_sequence) ''';
    const_string = '"' (input_string | escape_sequence)* '"';

    char = 'char';
    int = 'int';

    and = 'and';
    or = 'or';
    not = 'not';

    if = 'if';
    then = 'then';
    else = 'else';

    while = 'while';
    do = 'do';

    nothing = 'nothing';

    function = 'fun';

    reference = 'ref';

    return = 'return';

    variable = 'var';

    identifier = letter (letter | digit | '_')*;

   // blank = (' ' |13 | 10 | '\t' | 9 | 32)+;
    white_spaces = white_space+;

    esc_sequence = escape_sequence;

Ignored Tokens
    white_spaces, comment;


Productions

    program =
        {func_def}  function_definition |
        {command}   commd+;

    commd =
        stmt;

    block =
        {block} l_brc stmt* r_brc;

    stmt =
        {semi} semi |
        {assignment} l_value assign expr semi |
        {block} block |
        {func_call} func_call semi |
        {if} if_stmt |
        {while} while cond do stmt |
        {return} return expr? semi;

    if_stmt =
        {without_else} if cond then stmt |
        {with_else} if cond then stmt_with_else else stmt;

    stmt_with_else =
        {semi} semi |
        {assignment} l_value assign expr semi |
        {block} block |
        {func_call} func_call semi |
        {if_else} if cond then [id1]:stmt_with_else else [id2]: stmt_with_else |
        {while} while cond do stmt_with_else |
        {return} return expr? semi;


/*
    stmt =
        {matched} matched |
        {unmatched} unmatched;


    matched =
        {semi} semi |
        {assignment} l_value assign expr semi |
        {block} block |
        {func_call} func_call semi |
        {if_else} if cond then [id1]: matched else [id2]: matched |
        {while} while cond do stmt |
        {return} return expr? semi;

    unmatched =
        {if} if cond then stmt |
        {if_else} if cond then matched else unmatched;
*/
    expr =
        {factor} factor |
        {plus} expr plus factor |
        {minus} expr minus factor;

    factor =
        {expr_par}  expr_par |
        {mult} factor mult expr_par |
        {div} factor div expr_par |
        {mod} factor mod expr_par;

    expr_par =
        {term} term_sign |
        {par} l_par expr r_par;

    term_sign =
         {term} term |
         {sign_plus} plus term |
         {sign_minus} minus term;

    term =
         {int_const} number |
         {char_const} const_char |
         {l_value} l_value |
         {func_call} func_call;

    cond =
         {cond} cond_and |
         {cond_or} cond or cond_and;

    cond_and =
         {cond} cond_not |
         {cond_and} cond_and and cond_not;

    cond_not =
         {cond} cond_par |
         {cond_not} not cond_not;

    cond_par =
         {expr} cond_relat |
         {cond} l_par cond r_par;

    cond_relat =
         {cond_relat} [id1]: expr relat_oper [id2]: expr;

    relat_oper =
         {equal} equal |
         {n_equal} n_equal |
         {less} less |
         {less_equal} less_equal |
         {greater} greater |
         {greater_equal} greater_equal;


    //Functions Definition
    function_definition =
        header local_definition* block;


    //HEADER
    header =
         {header} function identifier l_par function_parameters? r_par colon ret_type;


    //Function Parameters
    function_parameters =
        {fpar} fparameters_definition semi_function_parameters*;

    semi_function_parameters =
        {semi_fpar} semi fparameters_definition;

    fparameters_definition =
        {fpar_def} reference? identifier comma_identifier* colon fpar_type;

    comma_identifier =
        {comma_id} comma identifier;

    //Type
    ret_type =
        {data} data_type |
        {noth} nothing;

    data_type =
        {int_type}  int |
        {char_type} char;

    type =
        {type} data_type const_int_brackets*;

    fpar_type =
        {type} data_type empty_brackets? const_int_brackets*;

    const_int_brackets =
        {array_type} l_bkt number r_bkt;

    empty_brackets =
        {empty} l_bkt r_bkt;


    //LOCAL FUNCTION DEFINITION
    local_definition =
        {func_def}  function_definition |
        {func_decl} function_declaration |
        {var_def}   variable_definition;

    variable_definition =
        {var} variable identifier comma_identifier* colon type semi;

    function_declaration =
        {func_decl} header semi;


    //Function Call
    func_call =
        {func_call} identifier l_par func_call_expr? r_par;

    func_call_expr =
        {expr_comma_expr} expr comma_expr*;

    comma_expr =
        {comma_expr} comma expr;

    l_value =
         {id} identifier |
         {string_literal} const_string |
         {l_value} l_value l_bkt expr r_bkt;
